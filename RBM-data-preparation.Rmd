---
title: "RMS Questionnaire v3.2 - Data Preparation (Step 1)" 
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true

---

Date: Last revision was on October 2024 

*For any issues please contact Ilgi Bozdag at bozdag@unhcr.org*

* ðŸ”— **GitHub Repositories:**
    + [Main link](https://github.com/bozdagilgi/UNHCR-RMS-Indicators)
    + [CAPI v3.2 Data Preparation](https://github.com/bozdagilgi/UNHCR-RMS-Indicators/blob/main/RBM-Data-Preparation-V3.2-CAPI.R)
    + [CAPI v3.2 RBM Indicators](https://github.com/bozdagilgi/UNHCR-RMS-Indicators/blob/main/RBM-Indicators-V3.2-CAPI.R)
    
**The above refers to the v3.2 RMS questionnaire, which is the final version. For all other versions, please visit the main link**  


**If the provided link above is not opening automatically, please right-click and copy the link manually!**

*Important Instructions:*

1. Here you will find all scripts that you need to prepare your data for indicator calculations. If you made some changes to RMS standard questionnaire, make sure adjust below script accordingly!

2. You can find all guidance pieces related to RMS on [Intranet](https://intranet.unhcr.org/en/support-services/common-good-data-initiatives/household-surveys/rms/rms-guidance-tools.html)

# **Prepare your RMS data**


## Step 0: Clear environment, install and load packages

```{r, eval=FALSE}

##Remove past activities

rm(list = ls())

####Load libraries and data ----

# Install pacman if not already installed
if(!require(pacman)) install.packages('pacman')

# Install the remotes package for GitHub installations
install.packages("remotes")

# Load all required libraries using pacman
pacman::p_load(
  tidyverse, dplyr, tidyr, rlang, purrr, magrittr, expss, srvyr, 
  readr, labelled, pastecs, psych, tableone, outbreaks, ggplot2, 
  unhcrthemes, scales, gt, webshot2, sjlabelled, waffle, writexl, 
  haven, readxl, dm, janitor, visdat, DiagrammeR, robotoolbox, remotes
)

# Install GitHub packages if needed
remotes::install_github("unhcr/unhcrthemes")
remotes::install_github("dickoa/robotoolbox")




```


## Step 1 : Import Data from  UNHCR KoBo server

[UNHCR Kobo server](https://kobo.unhcr.org/) serves as UNHCR' primary data collection tool. We strongly encourage the use of UNHCR's Kobo server for RMS data collection, and we kindly request that any exceptions be discussed with DIMA statisticians in your region. Whenever possible, please prioritize Kobo, as the current XLS form is fully compatible with KoBo sytem. Your cooperation is greatly appreciated.

After successfully completing your data collection, you have the convenient option to directly import your RMS data from the UNHCR Kobo server. By doing so, you can skip the steps of downloading and re-uploading your data, which not only streamlines the process but also saves you valuable time. To guide you through this seamless procedure, please follow the steps below.

If you opt to upload your data directly from your desktop, this document provides guidance on this at the end of this step.

##### Option 1. Pull your data from UNHCR KoBO Server

1. Insert your username and password from UNHCR Kobo server. You need to have access to the survey from your account to be able to upload it directly

```{r, eval=FALSE}


###Enter your KoBo username and password
kobo_token(username = "xxxxx",
           password = "xxxxx",
           url = "https://kobo.unhcr.org")


###Once you enter, you will receive your token from KoBO which you need to insert as below

kobo_setup(url = "https://kobo.unhcr.org",
           token = "xxxxx")

###Run the script below to see list of your surveys 
asset_list <- kobo_asset_list()

asset_list

##Find the survey you want to analyse and enter the name as below 

uid <- filter(asset_list, name == "RMS CAPI v3.2") |> ## change the name accordingly
  pull(uid)

###You will see the number of submissions and name. 

asset <- kobo_asset(uid)
asset


###Your data frame will be displayed here without the need for you to download it from KoBo
df <- kobo_data(asset)
df

## Get individual tables from data frame object if needed

main <- pull_tbl(df, main, keyed = TRUE)
S1 <- pull_tbl(df, S1, keyed = TRUE)
S2_repeat <- pull_tbl(df, S2_repeat, keyed = TRUE)
```

##### Option 2. Import your data from a file path

If you do so, please make sure to download your data from KoBo by selecting options as below:
1. Select export type: XLS
2. Value and Header format: XML values and headers

```{r, eval=FALSE}

####RMS dataset will have 2 other sheets due to individual level questions. 
####Export them separately by precising the name of the sheet as below

library(readxl)

main <- read_excel("Enter file path")
S1 <- read_excel("Enter file path", 
                 sheet = "S1")
S2_repeat <- read_excel("Enter file path", 
                    sheet = "S2_repeat")




```



3. Review your datasets: By now, you should have your datasets successfully imported.

```{r, eval=FALSE}
###Please use the same variable names, otherwise this script won't work

glimpse(df$main)
glimpse(df$S1)
glimpse(df$S2_repeat)

#Check repeat group datasets
dm_draw(df)

### Check the columns
glimpse(df)

##Check number of entries in each sheet
dm_nrow(df)


#### You can pull below three datasets

main <- pull_tbl(df, main, keyed = FALSE)
S1 <- pull_tbl(df, S1, keyed = FALSE)
S2_repeat <- pull_tbl(df, S2_repeat, keyed = FALSE)

##Merge all individual level dataset into one single individual dataset

S1 <- pull_tbl(df, S1, keyed = FALSE)
S2_repeat <- pull_tbl(df, S2_repeat, keyed = FALSE)

ind <- S1 |>
  left_join(S2_repeat, by = c("_index", "_parent_index")) 

#Now you should have only two datasets one is called 'main' for household level questions 
###and other one is called 'ind' for individual level questions


###Remove all other datasets that are not needed

rm(asset,asset_list,df,P2.3,S1, S2_repeat)



```



## Step 2 : Merge and clean your dataset

Below are the main requirements for the cleaned RMS dataset before you can start calculating RBM indicators. Computation of socio-demographic variables is also needed before merging the data. These variables will be used for disaggregation of RBM indicators. Thus, it should be as standardized as possible.



1. **Labelled variable names and response options**
    + Variable names and response options are labeled
    + All variables that will be used for indicator calculations will be numeric. RBM standard indicator calculation scripts assumes that the indicators are converted into numeric already.
    + Response options are standardized to have response options coded into corresponding number as shown below.
    + If you use the standard RMS CAPI/CATI questionnaire, all variables will appear with the response options as below.

Response Options | Code
---------------- |------
Other (specify)  |96
Don't know       |98
Prefer Not to say|99
Yes              |1
No 	             |0

2. **Merge individual and household level datasets**

   + Merge all individual datasets as done in the previous step.
   + Main household dataset doesnâ€™t have the demographic indicators (while the respondent information for randomly selected adult can be found within individual dataset) â€“ merge these variables with the main dataset to be able to disaggregate by household characteristics.


3. **Weights**

   + Compare the basic demographic indicators against the sampling frame. If different, calculate the weights and adjust the sample by using population weights
	 + Provide documentation on sample selection procedure, methodology and dictionary for labels while sharing cleaned data to make sure that the dataset as easy as possible to understand by third person
	 + Individual level dataset also need to be weighted, insert weights ( if any) in both datasets ( discuss if, there is a need to use different weights for individual level dataset)
   + Check non-response rates and adjust weights based on non-response if needed

4. **Data quality assurance**

   + Check for data quality by simple frequencies, and get rid of extreme values if any.
   + Make sure that questionnaire will be ready to run standard indicator calculations script, and try to adjust the dataset to the standard RMS questionnaire as much as possible.



__There is already existing scripts for standard RMS datasets that will guide you to merge your dataset. You can modify below scripts where needed if you made changes to the standard RMS questionnaire.__

> While there is no standard script for data cleaning, the points above will guide you on how to prepare and clean your data. Each dataset will have different needs that will require a closer look for data cleaning.Your data analyst should have the technical capacity to detect any issues with the dataset. When the data is verified and confirmed, and weights are inserted, you can start with the data manipulation.

You can use points below as an addition for data cleaning.

1. You can confirm by using the script below to see if there are any duplicates, if there are, please delete.

```{r, eval=FALSE}

duplicated(main) # Check if there are any duplicates
sum(duplicated(main)) # Number of duplicates


duplicated(ind) # Check if there are any duplicates
sum(duplicated(ind)) #Number of duplicates

get_dupes(main)
get_dupes(ind)

```



2. Check for missing data

```{r, eval=FALSE}

####R provides functions like is.na(), complete.cases(), and na.omit() for handling missing values. 
###The tidyr package's drop_na() function is also useful for removing rows with missing data
###Check for certain variables to see if there are any missing values

###Missing ind Analysis: Visualize the extent of missing ind using bar charts or heatmaps to identify patterns of missingness.

# Example of a missing ind heatmap using the `visdat` package


vis_dat(main)
```

3. Validate the sampling frame population groups

```{r, eval=FALSE}
### If you were surveying internally displaced persons, you can run the script below and compare with the actual
##population groups entered at the beginning

####IDPs 

###EGRISS defines IDPs as those who have been forcibly displaced , including preventative movements, by:
###Armed conflit; generalised violence; violations of human rights; natural or human-made disasters; other forced displacement or evictions


table(ind$IDP01_1) # Armed conflict
table(ind$IDP01_2) # Generalised Violence
table(ind$IDP01_3) # Persecution and or violations of human rights
table(ind$IDP01_4) # Natural or human-made disasters
table(ind$IDP01_5) # Other forced displacement or evictions
table(ind$IDP01_6) # Other voluntary movements
table(ind$IDP01_7) # Never moved home while in ${countryname}
table(ind$IDP01_98) # Don't know
table(ind$IDP01_99) # Prefer not to respond

ind <- ind %>%
  mutate(idp_valid=
           case_when(IDP01_1==1 | IDP01_2==1 | IDP01_3==1 | IDP01_4==1 | IDP01_5==1 ~ 1, 
                     IDP01_6==0 | IDP01_7==0 ~ 0,
                     TRUE ~ NA_real_)
  ) %>%
  mutate(idp_valid = labelled(idp_valid,
                              labels = c(
                                "Not an internally displaced person" = 0,
                                "Internatlly displaced person" = 1)
                              
  ))




###Check the results and compare with population group selected for the household for ind cleaning
table(ind$idp_valid)


####Refugees and Asylum Seekers

###You should check the primary citizenship of all household members and confirm that 
####refugees and asylum seekers are NOT the citizens of the country of enumeration

ind <- ind |>
  mutate( # primary citizenship from REF01 and REF02
    citizenship = case_when(
      REF01 == "1" ~ "XXX", ##here enter the country code (where RMS took place)
      REF01 %in% c("0", "98") ~ as.character(ind$REF02),
      REF01 == "99" ~ "99"
    )
  ) |>
  mutate(citizenship = labelled(citizenship,
                                labels = val_labels(ind$REF02),
                                label = var_label(ind$REF02)))
table(ind$citizenship)

```



Please make sure that scripts that were used for data cleaning should be documented and shared later while uploading the data on [RIDL](https://ridl.unhcr.org/).

Before start merging individual level datasets coming from repeat group questions, verify the names of these datasets.

At this point you should have two different datasets *ind* and *main*. Before we merge some variables into individual and household level dataset, we will compute all necessary variables.
Prior to this step you might want to create a function that can turn character values into numeric in case some of the variables are character variables. This step is not obligatory.

```{r, eval=FALSE}
###Create function that turn character values into numeric
labelled_chr2dbl <- function(x) {
  varlab <- var_label(x)
  vallab <- val_labels(x)
  vallab <- setNames(as.numeric(vallab),
                     names(vallab))
  x <- as.numeric(as.character(x))
  var_label(x) <- varlab
  val_labels(x) <- vallab
  x
}
```


## Step 3 : Compute socio-demographic variables

##### Country of origin

The information on the primary citizenship comes from the individual dataset - mobility section. To have one single variable for country of origin information, the country code for the country of enumeration (i.e. ZAF for South Africa) will be entered as below.


```{r, eval=FALSE}
ind <- ind |>
  mutate( # primary citizenship from REF01 and REF02
    citizenship = case_when(
      REF01 == "1" ~ "XXX", ##here enter the country code (where RMS took place)
      REF01 %in% c("0", "98") ~ as.character(ind$REF02),
      REF01 == "99" ~ "99"
    )
  ) |>
  mutate(citizenship = labelled(citizenship,
                                labels = val_labels(ind$REF02),
                                label = var_label(ind$REF02)))
table(ind$citizenship)


```

##### Age groups

The age variable also comes from the individual dataset. It will be useful to create two different age categories for reporting purposes. HH07 is the age variable from the individual dataset. Please change the name of variable if you are not using the standard RMS CAPI questionnaire.

```{r, eval=FALSE}
#####Age groups

ind$HH07_cat <- cut(ind$HH07,
                    breaks = c(-1, 4, 17, 59, Inf),
                    labels = c("0-4", "5-17", "18-59", "60+"))
ind$HH07_cat2 <- cut(ind$HH07 ,
                     breaks = c(-1, 17, Inf),
                     labels = c("0-17", "18-60+"))

table(ind$HH07_cat)
table(ind$HH07_cat2)



```


##### Disability

Disability questions comes from the household roster individual dataset. This module is taken from The Washington Group on Disability Statistics (WG) promotes and coordinates international cooperation in the area of health statistics focusing on the development of disability measures suitable for census and national surveys. 

The calculation for this section is standard. For more details, please refer [here](https://www.washingtongroup-disability.com/fileadmin/uploads/wg/WG_Document__7A_-_Analytic_Guidelines_for_the_WG-SS_Enhanced__SPSS_.pdf)  


```{r, eval=FALSE}

###Step 1: Generate frequency distributions on each of the six WG-SS domain variables

### 1	No difficulty
### 2	Some difficulty
### 3	A lot of difficulties
### 4	Cannot do at all
### 98	Donâ€™t know
### 99	Prefer not to respond

#Vision
barplot(table(ind$DIS01), main = "Vision")
#Hearing
barplot(table(ind$DIS02), main = "Hearing")
#Mobility
barplot(table(ind$DIS03), main = "Mobility")
#Communication
barplot(table(ind$DIS04), main = "Communication")
#Self-care
barplot(table(ind$DIS05), main = "Self-care")
#Cognition
barplot(table(ind$DIS06), main = "Cognition")


#######Step 2. Codes (99) Prefer not to respond and (98) Donâ€™t know, are recoded to Missing.

##Check your variable if it's numeric
class(ind$DIS01)

###Turn all character variables into numeric

ind$DIS01 <- labelled_chr2dbl(ind$DIS01)
ind$DIS02 <- labelled_chr2dbl(ind$DIS02)
ind$DIS03 <- labelled_chr2dbl(ind$DIS03)
ind$DIS04 <- labelled_chr2dbl(ind$DIS04)
ind$DIS05 <- labelled_chr2dbl(ind$DIS05)
ind$DIS06 <- labelled_chr2dbl(ind$DIS06)

##Check your variable again to confirm if itis now numeric
class(ind$DIS01)

# Replace "98"  and "99" with "NA" using dplyr

ind <- ind %>%
  mutate(
    DIS01 = ifelse(DIS01 == 98 | DIS01 == 99, NA, DIS01),
    DIS02 = ifelse(DIS02 == 98 | DIS02 == 99, NA, DIS02),
    DIS03 = ifelse(DIS03 == 98 | DIS03 == 99, NA, DIS03),
    DIS04 = ifelse(DIS04 == 98 | DIS04 == 99, NA, DIS04),
    DIS05 = ifelse(DIS05 == 98 | DIS05 == 99, NA, DIS05),
    DIS06 = ifelse(DIS06 == 98 | DIS06 == 99, NA, DIS06)
  )


####Double check for missing values

frequencies_DIS01 <- table(ind$DIS01, useNA = "ifany")
print(frequencies_DIS01)



####Create disability status indicator for the Washington Group short set on disability


ind$disability<- 0

ind <- ind %>%
  mutate(disability = ifelse(
    DIS01 %in% c(3, 4) |
      DIS02 %in% c(3, 4) |
      DIS03 %in% c(3, 4) |
      DIS04 %in% c(3, 4) |
      DIS05 %in% c(3, 4) |
      DIS06 %in% c(3, 4),
    1,
    disability
  ))


###Put the labels 
ind <- ind %>%
  mutate(disability = factor(disability, levels = c(0, 1), labels = c("Non-disabled", "Disabled")))



####Check final frequencies

table(ind$disability)


```


## Step 4 : Insert disaggregation variables into both individual and main datasets


This is the last step before the RMS dataset is ready for RBM indicator calculations. If you are at this step, it means that your data is already cleaned, merged and all disaggregation variables (disability, country of origin and age categories) are computed.

Below indicators will be used to disaggregate during the analysis.


1. Country of origin : `citizenship`
2. Age categories : `HH07_cat` and `HH07_cat2`
3. Gender : `HH04`
4. Population groups: `pop_groups`
5. Disability: `disability`

## Step 4: Add labels for above variables

```{r, eval=FALSE}


##Label the variables below 

pop_groups_labels <- c(
  "1" = "Asylum-seekers",
  "2" = "Refugees",
  "3" = "People in a refugee-like situation",
  "4" = "Refugee returnees",
  "5" = "IDPs",
  "6" = "IDP returnees",
  "7" = "Stateless people",
  "8" = "Host communities"
)

main <- main %>%
  mutate(pop_groups = recode_factor(pop_groups, !!!setNames(as.character(pop_groups_labels), as.character(seq_along(pop_groups_labels)))))


##Label HH04 - sex variable


# Define labels for HH04
HH04_labels <- c(
  "1" = "Female",
  "2" = "Male",
  "3" = "Intersex",
  "99" = "Prefer not to respond"
)

ind <- ind %>%
  mutate(HH04 = recode_factor(HH04, !!!setNames(as.character(HH04_labels), as.character(seq_along(HH04_labels)))))


main <- main %>%
  mutate(EDU01_random = factor(EDU01_random, 
                               levels = c(0, 1, 2, 3, 4, 5, 6, 8, 9, 98, 99),
                               labels = c("No formal education",
                                          "Informal schooling only",
                                          "Less than primary education",
                                          "Primary school completed",
                                          "Lower secondary school completed",
                                          "Upper secondary school completed",
                                          "Post-secondary non-tertiary education",
                                          "Bachelor/equivalent degree completed",
                                          "Masters/equivalent degree or above",
                                          "Don't know",
                                          "Prefer not to respond")))


table(main$EDU01_random)

```



##### Import individual level variables to household level (main) dataset

In the standard RMS CAPI questionnaire, some of the individual level modules are asked to randomly selected adult. As a result, while the information is in individual dataset, questions are located in the main dataset. There is a need to merge the randomly selected adult by the name and age and merge it into main dataset.

```{r, eval=FALSE}
####RANDOMLY SELECTED ADULT  


###Run this step if only you have extra variable for the first selected with the same name
main$name_selectedfirst <- ifelse(is.na(main$name_selectedadult18), main$name_selectedadult18_1, main$name_selectedadult18)

table(main$name_selectedfirst)


###Create a variable called random_adult to match with the main dataset

main <- main %>%
  mutate(random_adult=case_when(
    random_present %in% c(1,3) ~ name_selectedfirst,
    random_present_2 %in% c(1,3) ~ name_selectedadult18_2,
    TRUE ~ name_respondent)
         )


table(main$random_adult)


##Create a new dataset with indicators for merge, below you can add all other indicators you want to import from individual dataset



ind_m <- ind %>% ###Here below add idp_valid if only you have IDPs 
  select("_parent_index", "HH07_cat", "HH07_cat2", "disability",
         "citizenship","idp_valid", "HH07", "HH04", "HH03", "name_individual", "HH01" ) 



main <- left_join(main, ind_m,
                  by = c("random_adult"="name_individual", "_index" = "_parent_index"))

rm(ind_m)
```



##### Import household level variables (main) to individual dataset

There are disaggregation variables such as population groups are not available in the individual level dataset.

```{r, eval=FALSE}

##Create a new dataset with the indicators that you want to import

main_m <- main %>%
  select("_index", pop_groups, end_result) ## add variables here

ind <- left_join(main_m, ind, 
                 by = c("_index" = "_parent_index"))

rm(main_m)

```


## Step 5: Data Cleaning


Before you start creating variables for further disaggregation, CLEAN your RMS data!
You can get inspired from below steps to help you with your primary cleaning that was done in Step 1.



1. Data Type Conversion 


Use functions like `as.numeric()`, `as.character()`, or `as.Date()` to convert ind types as needed

2.Document your cleaning decisions

Document the data cleaning steps and decisions using comments in your R script or a separate documentation file.

Add comments in your script or R Markdown to explain what changes were made and why.


3. Perform Exploratory ind Analysis (EDA)

Conduct EDA to understand the distribution, relationships, and patterns in the cleaned data.
Visualize the data using plots or charts to identify any anomalies.

*EDA Analysis*


NOTE THAT -  You can access the respective codes for response options within your KoBo form

+ Summary Statistics: Compute basic statistics like mean, median, standard deviation and quartiles for numerical variables using the `summary()`, `mean()`, `median()`, `sd()`, `quantile()`, or `summary()` functions.


+ Histograms: Create histograms to visualize the distribution of numerical ind using the `hist()` function.

For instance you should check below and confirm that there are no adults below 18

```{r, eval=FALSE}
hist(main$HHH01_age, main = "Histogram of the age of household head")
hist(main$HH07)

```



+ Bar Plots: For categorical ind, create bar plots to visualize the distribution using the `barplot()` or ggplot2 package.


```{r, eval=FALSE}

# Example of a bar plot

barplot(table(main$pop_groups), main = "Population groups")


```

+ Scatter Plots: Visualize relationships between two numerical variables using scatter plots with `plot()` or `ggplot2`. 
This helps identify correlations and patterns.


```{r, eval=FALSE}

# Example of a scatter plot
plot(ind$num_var1, ind$num_var2, main = "Scatter Plot")
```


**After performing these primary ind quality checks, your data should be validated and ready for calculation of the variables**

1. Compare Results with Expectations
2. Compare the results of your analysis with your expectations to identify discrepancies.
3. Document the Validation Process
4. Keep detailed records of the checks, validations, and their outcomes for future reference.
5. If issues or discrepancies are identified during validation, you may need to revisit the ind cleaning process and make necessary adjustments.




## Step 6: Save your datasets

```{r, eval=FALSE}
# Create a new dataset with only required variables

###For individual dataset

vars_to_remove_ind <- c("hhroster_pos_aux", "ageMD", "age18above", "age_est", "month_est", "position", "position18",
                    "Relation_R", "adult18", "women_b_count", "women_b", "father_b", "childLess2", "childLess2name",
                    "women", "father", "adult", "adult_sum", "adult01")

ind <- ind[, !(names(ind) %in% vars_to_remove_ind)]

###For main dataset


vars_to_remove_main <- c("namechild2less", "nochildless2", "women_name_b_total", "women_name_b", "father_name_b",
                         "women_name", "father_name", "random1ap", "random1ap2", "eadult_nap", "eadult_nap2",
                         "epositionap", "epositionap2", "random_indexap", "random_indexap2", "selected_adultap",
                         "selected_adultap2")

main <- main[, !(names(main) %in% vars_to_remove_main)]



#####Export datasets for RIDL upload as cleaned versions

 #### Individual dataset

# Specify the file path where you want to export the dataset

file_path <- "path/to/your/directory/your_data.csv"

# Export the 'ind' dataset to a CSV file at the specified file path
write.csv(ind, file = file_path, row.names = FALSE)

# Check if the file was created at the specified path
if (file.exists(file_path)) {
  cat("Dataset exported to", file_path, "\n")
} else {
  cat("Export failed\n")
}



#### Main dataset

# Specify the file path where you want to export the dataset

file_path <- "path/to/your/directory/your_data.csv"

# Export the 'ind' dataset to a CSV file at the specified file path
write.csv(main, file = file_path, row.names = FALSE)

# Check if the file was created at the specified path
if (file.exists(file_path)) {
  cat("Dataset exported to", file_path, "\n")
} else {
  cat("Export failed\n")
}


```

If you've been through all the steps as explained above, your dataset is ready to be used for RBM indicator calculations. Make sure to include 'weights' variable if there is any in both individual and household level datasets.

Here is the link for [indicator calculations](https://rstudio.unhcr.org/RBM-indicators/) . 
